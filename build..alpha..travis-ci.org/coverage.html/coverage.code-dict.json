{"/home/travis/build/npmtest/node-npmtest-socketcluster/test.js":"/* istanbul instrument in package npmtest_socketcluster */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-socketcluster/lib.npmtest_socketcluster.js":"/* istanbul instrument in package npmtest_socketcluster */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_socketcluster = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_socketcluster = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-socketcluster/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-socketcluster && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_socketcluster */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_socketcluster\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_socketcluster.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_socketcluster.rollup.js'] =\n            local.assetsDict['/assets.npmtest_socketcluster.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_socketcluster.__dirname + '/lib.npmtest_socketcluster.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster/index.js":"var path = require('path');\nvar crypto = require('crypto');\nvar EventEmitter = require('events').EventEmitter;\nvar domain = require('sc-domain');\nvar fork = require('child_process').fork;\nvar os = require('os');\nvar fs = require('fs-extra');\nvar uidNumber = require('uid-number');\nvar uuid = require('uuid');\nvar pkg = require('./package.json');\nvar argv = require('minimist')(process.argv.slice(2));\nvar cluster = require('cluster');\n\nvar scErrors = require('sc-errors');\nvar InvalidOptionsError = scErrors.InvalidOptionsError;\nvar InvalidActionError = scErrors.InvalidActionError;\nvar BrokerError = scErrors.BrokerError;\nvar ProcessExitError = scErrors.ProcessExitError;\nvar UnknownError = scErrors.UnknownError;\n\nvar socketClusterSingleton = null;\n\nvar SocketCluster = function (options) {\n  var self = this;\n  if (socketClusterSingleton) {\n    var doubleInstantiationError = new Error('The SocketCluster master object is a singleton - It can only be instantiated once per process.');\n    doubleInstantiationError.name = 'DoubleInstantiationError';\n    throw doubleInstantiationError;\n  }\n  socketClusterSingleton = self;\n\n  self.EVENT_FAIL = 'fail';\n  self.EVENT_WARNING = 'warning';\n  self.EVENT_INFO = 'info';\n  self.EVENT_READY = 'ready';\n  self.EVENT_WORKER_START = 'workerStart';\n  self.EVENT_WORKER_EXIT = 'workerExit';\n\n  self._errorAnnotations = {\n    'EADDRINUSE': 'Failed to bind to a port because it was already used by another process.'\n  };\n\n  self._errorDomain = domain.create();\n  self._errorDomain.on('error', function (err) {\n    self.errorHandler(err, {\n      type: 'master'\n    });\n  });\n  self._errorDomain.add(self);\n\n  self._errorDomain.run(function () {\n    self._init(options);\n  });\n};\n\nSocketCluster.prototype = Object.create(EventEmitter.prototype);\n\nSocketCluster.prototype._init = function (options) {\n  var self = this;\n\n  var backslashRegex = /\\\\/g;\n  var appDirPath = path.dirname(require.main.filename).replace(backslashRegex, '/');\n\n  self.options = {\n    port: 8000,\n    workers: null,\n    brokers: null,\n    appName: null,\n    instanceId: null,\n    secretKey: null,\n    authKey: null,\n    authPrivateKey: null,\n    authPublicKey: null,\n    authDefaultExpiry: 86400,\n    authAlgorithm: null,\n    authSignAsync: false,\n    authVerifyAsync: true,\n    crashWorkerOnError: true,\n    rebootWorkerOnCrash: true,\n    killWorkerMemoryThreshold: null,\n    protocol: 'http',\n    protocolOptions: null,\n    logLevel: 2,\n    handshakeTimeout: 10000,\n    ackTimeout: 10000,\n    pingInterval: 8000,\n    pingTimeout: 20000,\n    origins: '*:*',\n    socketChannelLimit: 1000,\n    workerStatusInterval: 10000,\n    processTermTimeout: 10000,\n    propagateErrors: true,\n    propagateWarnings: true,\n    middlewareEmitWarnings: true,\n    host: null,\n    tcpSynBacklog: null,\n    workerController: null,\n    brokerController: null,\n    initController: null,\n    rebootOnSignal: true,\n    downgradeToUser: false,\n    path: '/socketcluster/',\n    socketRoot: null,\n    schedulingPolicy: null,\n    allowClientPublish: true,\n    defaultWorkerDebugPort: 5858,\n    defaultBrokerDebugPort: 6858,\n    httpServerModule: null,\n    pubSubBatchDuration: null,\n    environment: 'dev',\n    killMasterOnSignal: false,\n    wsEngine: 'uws',\n    brokerEngine: 'sc-broker-cluster'\n  };\n\n  self._active = false;\n  self._workerCluster = null;\n\n  self._colorCodes = {\n    red: 31,\n    green: 32,\n    yellow: 33\n  };\n\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      self.options[i] = options[i];\n    }\n  }\n\n  // Make sure there is always a trailing slash in WS path\n  self.options.path = self.options.path.replace(/\\/?$/, '/');\n\n  var maxTimeout = Math.pow(2, 31) - 1;\n\n  var verifyDuration = function (propertyName) {\n    if (self.options[propertyName] > maxTimeout) {\n      throw new InvalidOptionsError('The ' + propertyName +\n        ' value provided exceeded the maximum amount allowed');\n    }\n  };\n\n  verifyDuration('ackTimeout');\n  verifyDuration('pingInterval');\n  verifyDuration('pingTimeout');\n  verifyDuration('workerStatusInterval');\n  verifyDuration('processTermTimeout');\n\n  if (self.options.appName == null) {\n    self.options.appName = uuid.v4();\n  }\n\n  if (self.options.workerController == null) {\n    throw new InvalidOptionsError(\"Compulsory option 'workerController' was not specified \" +\n      \"- It needs to be a path to a JavaScript file which will act as the \" +\n      \"boot controller for each worker in the cluster\");\n  }\n\n  self._paths = {\n    appDirPath: appDirPath,\n    statusURL: '/~status',\n    appWorkerControllerPath: path.resolve(self.options.workerController)\n  };\n\n  if (self.options.initController) {\n      self._paths.appInitControllerPath = path.resolve(self.options.initController);\n  } else {\n      self._paths.appInitControllerPath = null;\n  }\n\n  if (/\\.js$/.test(self.options.wsEngine)) {\n    self._paths.wsEnginePath = path.resolve(self.options.wsEngine);\n  } else {\n    self._paths.wsEnginePath = self.options.wsEngine;\n  }\n\n  var pathHasher = crypto.createHash('md5');\n  pathHasher.update(self._paths.appDirPath, 'utf8');\n  var pathHash = pathHasher.digest('hex').substr(0, 10);\n  // Trimp it because some OSes (e.g. OSX) do not like long path names for domain sockets.\n  var shortAppName = self.options.appName.substr(0, 13);\n\n  if (process.platform == 'win32') {\n    if (self.options.socketRoot) {\n      self._socketDirPath = self.options.socketRoot + '_';\n    } else {\n      self._socketDirPath = '\\\\\\\\.\\\\pipe\\\\socketcluster_' + shortAppName + '_' + pathHash + '_';\n    }\n  } else {\n    var socketDir, socketParentDir;\n    if (self.options.socketRoot) {\n      socketDir = self.options.socketRoot.replace(/\\/$/, '') + '/';\n    } else {\n      socketParentDir = os.tmpdir() + '/socketcluster/';\n      socketDir = socketParentDir + shortAppName + '_' + pathHash + '/';\n    }\n    if (fs.existsSync(socketDir)) {\n      try {\n        fs.removeSync(socketDir);\n      } catch (err) {\n        throw new InvalidActionError('Failed to remove old socket directory ' + socketDir + ' - Try removing it manually');\n      }\n    }\n    fs.mkdirsSync(socketDir);\n    if (socketParentDir) {\n      try {\n        fs.chmodSync(socketParentDir, '1777');\n      } catch (err) {}\n    }\n    self._socketDirPath = socketDir;\n  }\n\n  if (self.options.brokerController) {\n    self._paths.appBrokerControllerPath = path.resolve(self.options.brokerController);\n  } else {\n    self._paths.appBrokerControllerPath = null;\n  }\n\n  if (self.options.protocolOptions) {\n    var protoOpts = self.options.protocolOptions;\n    if (protoOpts.key instanceof Buffer) {\n      protoOpts.key = protoOpts.key.toString();\n    }\n    if (protoOpts.cert instanceof Buffer) {\n      protoOpts.cert = protoOpts.cert.toString();\n    }\n    if (protoOpts.ca) {\n      if (protoOpts.ca instanceof Array) {\n        protoOpts.ca = protoOpts.ca.map(function (item) {\n          if (item instanceof Buffer) {\n            return item.toString();\n          } else {\n            return item;\n          }\n        });\n      } else if (protoOpts.ca instanceof Buffer) {\n        protoOpts.ca = protoOpts.ca.toString();\n      }\n    }\n    if (protoOpts.pfx instanceof Buffer) {\n      protoOpts.pfx = protoOpts.pfx.toString('base64');\n    }\n    if (protoOpts.passphrase == null) {\n      if (protoOpts.key) {\n        var privKeyEncLine = protoOpts.key.split('\\n')[1];\n        if (privKeyEncLine.toUpperCase().indexOf('ENCRYPTED') > -1) {\n          var message = 'The supplied private key is encrypted and cannot be used without a passphrase - ' +\n            'Please provide a valid passphrase as a property to protocolOptions';\n          throw new InvalidOptionsError(message);\n        }\n      } else if (protoOpts.pfx) {\n        var message = 'The supplied pfx certificate cannot be used without a passphrase - ' +\n          'Please provide a valid passphrase as a property to protocolOptions';\n        throw new InvalidOptionsError(message);\n      } else {\n        var message = 'The supplied protocolOptions were invalid - ' +\n          'Please provide either a key and cert pair or a pfx certificate';\n        throw new InvalidOptionsError(message);\n      }\n    }\n  }\n\n  if (self.options.authPrivateKey instanceof Buffer) {\n    self.options.authPrivateKey = self.options.authPrivateKey.toString();\n  }\n  if (self.options.authPublicKey instanceof Buffer) {\n    self.options.authPublicKey = self.options.authPublicKey.toString();\n  }\n\n  if (!self.options.brokers || self.options.brokers < 1) {\n    self.options.brokers = 1;\n  }\n  if (typeof self.options.brokers != 'number') {\n    throw new InvalidOptionsError('The brokers option must be a number');\n  }\n\n  if (!self.options.workers || self.options.workers < 1) {\n    self.options.workers = 1;\n  }\n  if (typeof self.options.workers != 'number') {\n    throw new InvalidOptionsError('The workers option must be a number');\n  }\n\n  self._extRegex = /[.][^\\/\\\\]*$/;\n  self._slashSequenceRegex = /\\/+/g;\n  self._startSlashRegex = /^\\//;\n\n  self._dataExpiryAccuracy = 5000;\n\n  self._brokerEngine = require(self.options.brokerEngine);\n\n  if (self.options.logLevel > 0) {\n    console.log('   ' + self.colorText('[Busy]', 'yellow') + ' Launching SocketCluster');\n  }\n\n  process.stdin.on('error', function (err) {\n    self.warningHandler(err, {type: 'master'});\n  });\n\n  /*\n    To allow inserting blank lines in console on Windows to aid with debugging.\n  */\n  if (process.platform == 'win32') {\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n  }\n\n  if (self.options.downgradeToUser && process.platform != 'win32') {\n    if (typeof self.options.downgradeToUser == 'number') {\n      fs.chownSync(self._socketDirPath, self.options.downgradeToUser, 0);\n      self._start();\n    } else {\n      uidNumber(self.options.downgradeToUser, function (err, uid, gid) {\n        if (err) {\n          throw new InvalidActionError('Failed to downgrade to user \"' + self.options.downgradeToUser + '\" - ' + err);\n        } else {\n          fs.chownSync(self._socketDirPath, uid, gid);\n          self._start();\n        }\n      });\n    }\n  } else {\n    self._start();\n  }\n};\n\nSocketCluster.prototype._getBrokerSocketName = function (brokerId) {\n  return 'b' + brokerId;\n};\n\nSocketCluster.prototype._getBrokerSocketPaths = function () {\n  var socketPaths = [];\n  for (var i = 0; i < this.options.brokers; i++) {\n    socketPaths.push(this._socketDirPath + this._getBrokerSocketName(i));\n  }\n  return socketPaths;\n};\n\nSocketCluster.prototype._capitaliseFirstLetter = function (str) {\n  if (str == null) {\n    str = '';\n  }\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nSocketCluster.prototype._logObject = function (obj, objType, time) {\n  if (!objType) {\n    objType = 'Error';\n  }\n  if (!obj.origin) {\n    obj.origin = {};\n  }\n  if (!obj.origin.type) {\n    obj.origin.type = 'Undefined';\n  }\n  var output = obj.stack || obj.message || obj;\n\n  var logMessage;\n  if (obj.origin.pid == null) {\n    logMessage = 'Origin: ' + this._capitaliseFirstLetter(obj.origin.type) + '\\n' +\n      '   [' + objType + '] ' + output;\n  } else {\n    logMessage = 'Origin: ' + this._capitaliseFirstLetter(obj.origin.type) + ' (PID ' + obj.origin.pid + ')\\n' +\n      '   [' + objType + '] ' + output;\n  }\n  this.log(logMessage, time);\n};\n\nSocketCluster.prototype.errorHandler = function (err, origin) {\n  if (!(err instanceof Object)) {\n    // If a string (or null...)\n    err = new UnknownError(err);\n  } else if (err.stack == null) {\n    err.stack = err.message;\n  }\n  var annotation = this._errorAnnotations[err.code];\n  if (annotation) {\n    err.stack += '\\n    ' + this.colorText('!!', 'red') + ' ' + annotation;\n  }\n\n  err.origin = origin;\n  err.time = Date.now();\n  this.emit(this.EVENT_FAIL, err);\n\n  this._logObject(err, 'Error');\n};\n\nSocketCluster.prototype.warningHandler = function (warning, origin) {\n  if (!(warning instanceof Object)) {\n    // If a string (or null...)\n    warning = new UnknownError(warning);\n  } else if (warning.stack == null) {\n    warning.stack = warning.message;\n  }\n  warning.origin = origin;\n  warning.time = Date.now();\n\n  this.emit(this.EVENT_WARNING, warning);\n\n  if (this.options.logLevel > 1) {\n    this._logObject(warning, 'Warning');\n  }\n};\n\nSocketCluster.prototype.triggerInfo = function (info, origin) {\n  if (this._active) {\n    if (!(origin instanceof Object)) {\n      origin = {\n        type: origin\n      };\n    }\n    var infoData = {\n      origin: origin,\n      message: info,\n      time: Date.now()\n    };\n    this.emit(this.EVENT_WARNING, infoData);\n\n    if (this.options.logLevel > 0) {\n      this._logObject(infoData, 'Info', infoData.time)\n    }\n  }\n};\n\nSocketCluster.prototype._workerClusterErrorHandler = function (pid, error) {\n  this.errorHandler(error, {\n    type: 'WorkerCluster',\n    pid: pid\n  });\n};\n\nSocketCluster.prototype._workerErrorHandler = function (workerPid, error) {\n  this.errorHandler(error, {\n    type: 'Worker',\n    pid: workerPid\n  });\n};\n\nSocketCluster.prototype._brokerEngineErrorHandler = function (pid, error) {\n  if (typeof error == 'string') {\n    error = new BrokerError(error);\n  }\n  this.errorHandler(error, {\n    type: 'BrokerEngine',\n    pid: pid\n  });\n};\n\nSocketCluster.prototype._brokerErrorHandler = function (brokerPid, error) {\n  if (typeof error == 'string') {\n    error = new BrokerError(error);\n  }\n  this.errorHandler(error, {\n    type: 'Broker',\n    pid: brokerPid\n  });\n};\n\nSocketCluster.prototype._workerWarningHandler = function (workerPid, warning) {\n  var origin = {\n    type: 'Worker',\n    pid: workerPid\n  };\n  this.warningHandler(warning, origin);\n};\n\nSocketCluster.prototype._workerClusterReadyHandler = function () {\n  var self = this;\n\n  if (!this._active) {\n    if (this.options.rebootOnSignal) {\n      process.on('SIGUSR2', function () {\n        var warning;\n        var killOptions = {};\n        if (self.options.environment == 'dev') {\n          warning = 'Master received SIGUSR2 signal - Shutting down all workers immediately';\n          killOptions.immediate = true;\n        } else {\n          warning = 'Master received SIGUSR2 signal - Shutting down all workers in accordance with processTermTimeout';\n        }\n        self.warningHandler(warning, {type: 'master'});\n        self.killWorkers(killOptions);\n        if (self.options.killMasterOnSignal) {\n          process.exit();\n        }\n      });\n    }\n\n    this._active = true;\n    this._logDeploymentDetails();\n  }\n};\n\nSocketCluster.prototype._workerExitHandler = function (workerInfo) {\n  if (this.options.logLevel > 0) {\n    var message = 'Worker ' + workerInfo.id + ' exited - Exit code: ' + workerInfo.code;\n    if (workerInfo.signal) {\n      message += ', signal: ' + workerInfo.signal;\n    }\n    this.log(message);\n  }\n  this.emit(this.EVENT_WORKER_EXIT, workerInfo);\n};\n\nSocketCluster.prototype._workerStartHandler = function (workerInfo) {\n  if (this._active && this.options.logLevel > 0 && workerInfo.respawn) {\n    this.log('Worker ' + workerInfo.id + ' was respawned');\n  }\n  this.emit(this.EVENT_WORKER_START, workerInfo);\n};\n\nSocketCluster.prototype._handleWorkerClusterExit = function (errorCode) {\n  var message = 'workerCluster exited with code: ' + errorCode;\n  if (errorCode == 0) {\n    this.log(message);\n  } else {\n    var error = new ProcessExitError(message, errorCode);\n    this.errorHandler(error, {\n      type: 'workerCluster'\n    });\n  }\n  this._launchWorkerCluster();\n};\n\nSocketCluster.prototype._launchWorkerCluster = function () {\n  var self = this;\n\n  var debugPort, inspectPort;\n\n  // Workers should not inherit the master --debug argument\n  // because they have their own --debug-workers option.\n  var execOptions = {\n    execArgv: process.execArgv.filter(function (arg) {\n      return arg != '--debug' && arg != '--debug-brk' && arg != '--inspect';\n    })\n  };\n\n  if (argv['debug-workers']) {\n    if (argv['debug-workers'] == true) {\n      debugPort = this.options.defaultWorkerDebugPort;\n    } else {\n      debugPort = argv['debug-workers'];\n    }\n    execOptions.execArgv.push('--debug=' + debugPort);\n  }\n\n  if (argv['inspect-workers']) {\n    if (argv['inspect-workers'] == true) {\n      inspectPort = this.options.defaultWorkerDebugPort;\n    } else {\n      inspectPort = argv['inspect-workers'];\n    }\n    execOptions.execArgv.push('--debug-port=' + inspectPort);\n    execOptions.execArgv.push('--inspect=' + inspectPort);\n  }\n\n  this._workerCluster = fork(__dirname + '/lib/workercluster.js', process.argv.slice(2), execOptions);\n\n  var workerOpts = this._cloneObject(this.options);\n  workerOpts.paths = this._paths;\n  workerOpts.sourcePort = this.options.port;\n  workerOpts.workerCount = this.options.workers;\n  workerOpts.brokers = this._getBrokerSocketPaths();\n  workerOpts.secretKey = this.options.secretKey;\n  workerOpts.authKey = this.options.authKey;\n  workerOpts.authPrivateKey = this.options.authPrivateKey;\n  workerOpts.authPublicKey = this.options.authPublicKey;\n  workerOpts.authDefaultExpiry = this.options.authDefaultExpiry;\n  workerOpts.authAlgorithm = this.options.authAlgorithm;\n  workerOpts.authSignAsync = this.options.authSignAsync;\n  workerOpts.authVerifyAsync = this.options.authVerifyAsync;\n\n  if (typeof workerOpts.schedulingPolicy == 'string') {\n    if (workerOpts.schedulingPolicy == 'rr') {\n      workerOpts.schedulingPolicy = cluster.SCHED_RR;\n    } else if (workerOpts.schedulingPolicy == 'none') {\n      workerOpts.schedulingPolicy = cluster.SCHED_NONE;\n    }\n  }\n\n  this._workerCluster.send({\n    type: 'init',\n    data: workerOpts\n  });\n\n  this._workerCluster.on('message', function workerHandler(m) {\n    if (m.type == 'error') {\n      var error = scErrors.hydrateError(m.data.error);\n      if (m.data.workerPid) {\n        self._workerErrorHandler(m.data.workerPid, error);\n      } else {\n        self._workerClusterErrorHandler(m.data.pid, error);\n      }\n    } else if (m.type == 'warning') {\n      var warning = scErrors.hydrateError(m.data.error);\n      self._workerWarningHandler(m.data.workerPid, warning);\n    } else if (m.type == 'ready') {\n      self._workerClusterReadyHandler();\n    } else if (m.type == 'workerStart') {\n      self._workerStartHandler(m.data);\n    } else if (m.type == 'workerExit') {\n      self._workerExitHandler(m.data);\n    } else if (m.type == 'workerMessage') {\n      self.emit('workerMessage', m.workerId, m.data);\n    }\n  });\n\n  this._workerCluster.on('exit', this._handleWorkerClusterExit.bind(this));\n};\n\nSocketCluster.prototype._logDeploymentDetails = function () {\n  if (this.options.logLevel > 0) {\n    console.log('   ' + this.colorText('[Active]', 'green') + ' SocketCluster started');\n    console.log('            Version: ' + pkg.version);\n    console.log('            Environment: ' + this.options.environment);\n    console.log('            WebSocket engine: ' + this.options.wsEngine);\n    console.log('            Port: ' + this.options.port);\n    console.log('            Master PID: ' + process.pid);\n    console.log('            Worker count: ' + this.options.workers);\n    console.log('            Broker count: ' + this.options.brokers);\n    console.log();\n  }\n  this.emit(this.EVENT_READY);\n};\n\nSocketCluster.prototype._start = function () {\n  var self = this;\n\n  if (self.options.secretKey == null) {\n    self.options.secretKey = crypto.randomBytes(32).toString('hex');\n  }\n  if (this.options.authKey == null && this.options.authPrivateKey == null && this.options.authPublicKey == null) {\n    this.options.authKey = crypto.randomBytes(32).toString('hex');\n  }\n  if (self.options.instanceId == null) {\n    self.options.instanceId = uuid.v4();\n  }\n\n  self._active = false;\n\n  var brokerEngineServerReady = function () {\n    self._brokerEngineServer.removeListener('ready', brokerEngineServerReady);\n    self._launchWorkerCluster();\n  };\n\n  var launchBrokerEngine = function () {\n    var brokerDebugPort = argv['debug-brokers'];\n    if (brokerDebugPort == true) {\n      brokerDebugPort = self.options.defaultBrokerDebugPort;\n    }\n\n    var brokerInspectPort = argv['inspect-brokers'];\n    if (brokerInspectPort == true) {\n      brokerInspectPort = self.options.defaultBrokerDebugPort;\n    }\n\n    self._brokerEngineServer = new self._brokerEngine.Server({\n      brokers: self._getBrokerSocketPaths(),\n      debug: brokerDebugPort,\n      inspect: brokerInspectPort,\n      instanceId: self.options.instanceId,\n      secretKey: self.options.secretKey,\n      expiryAccuracy: self._dataExpiryAccuracy,\n      downgradeToUser: self.options.downgradeToUser,\n      processTermTimeout: self.options.processTermTimeout,\n      brokerOptions: self.options,\n      appBrokerControllerPath: self._paths.appBrokerControllerPath,\n      appInitControllerPath: self._paths.appInitControllerPath\n    });\n\n    self._brokerEngineServer.on('error', function (err) {\n      if (err.brokerPid) {\n        self._brokerErrorHandler(err.brokerPid, err);\n      } else {\n        self._brokerEngineErrorHandler(err.pid, err);\n      }\n    });\n\n    self._brokerEngineServer.on('ready', brokerEngineServerReady);\n\n    self._brokerEngineServer.on('brokerMessage', function (brokerId, data) {\n      self.emit('brokerMessage', brokerId, data);\n    });\n  };\n\n  launchBrokerEngine();\n};\n\nSocketCluster.prototype.sendToWorker = function (workerId, data) {\n  this._workerCluster.send({\n    type: 'masterMessage',\n    workerId: workerId,\n    data: data\n  });\n};\n\nSocketCluster.prototype.sendToBroker = function (brokerId, data) {\n  this._brokerEngineServer.sendToBroker(brokerId, data);\n};\n\n// The options object is optional and can have two boolean fields:\n// immediate: Shut down the workers immediately without waiting for termination timeout.\n// killClusterMaster: Shut down the cluster master (load balancer) as well as all the workers.\nSocketCluster.prototype.killWorkers = function (options) {\n  if (this._workerCluster) {\n    this._workerCluster.send({\n      type: 'terminate',\n      data: options || {}\n    });\n  }\n};\n\nSocketCluster.prototype.killBrokers = function () {\n  if (this._brokerEngineServer) {\n    this._brokerEngineServer.destroy();\n  }\n};\n\nSocketCluster.prototype.log = function (message, time) {\n  if (time == null) {\n    time = Date.now();\n  }\n  console.log(time + ' - ' + message);\n};\n\nSocketCluster.prototype._cloneObject = function (object) {\n  var clone = {};\n  for (var i in object) {\n    if (object.hasOwnProperty(i)) {\n      clone[i] = object[i];\n    }\n  }\n  return clone;\n};\n\nSocketCluster.prototype.colorText = function (message, color) {\n  if (this._colorCodes[color]) {\n    return '\\x1b[0;' + this._colorCodes[color] + 'm' + message + '\\x1b[0m';\n  } else if (color) {\n    return '\\x1b[' + color + 'm' + message + '\\x1b[0m';\n  }\n  return message;\n};\n\nmodule.exports.SocketCluster = SocketCluster;\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster/bin/cli.js":"#!/usr/bin/env node\n\nvar fs = require('fs-extra');\nvar path = require('path');\nvar argv = require('minimist')(process.argv.slice(2));\nvar childProcess = require('child_process');\nvar inquirer = require('inquirer');\nvar prompt = inquirer.createPromptModule();\nvar exec = childProcess.exec;\nvar spawn = childProcess.spawn;\nvar fork = childProcess.fork;\n\nvar command = argv._[0];\nvar commandRawArgs = process.argv.slice(3);\nvar arg1 = argv._[1];\nvar force = argv.force ? true : false;\n\nvar parsePackageFile = function (moduleDir) {\n  var packageFile = moduleDir + '/package.json';\n  try {\n    if (fs.existsSync(packageFile)) {\n      return JSON.parse(fs.readFileSync(packageFile, {encoding: 'utf8'}));\n    }\n  } catch (e) {}\n\n  return {};\n};\n\nvar errorMessage = function (message) {\n  console.log('\\033[0;31m[Error]\\033[0m ' + message);\n};\n\nvar successMessage = function (message) {\n  console.log('\\033[0;32m[Success]\\033[0m ' + message);\n};\n\nvar warningMessage = function (message) {\n  console.log('\\033[0;33m[Warning]\\033[0m ' + message);\n};\n\nvar showCorrectUsage = function () {\n  console.log('Usage: socketcluster [options] [command]\\n');\n  console.log('Options:');\n  console.log(\"  -v            Get the version of the current SocketCluster installation\");\n  console.log('  --help        Get info on how to use this command');\n  console.log('  --force       Force all necessary directory modifications without prompts');\n  console.log();\n  console.log('Commands:');\n  console.log('  create <appname>            Create a new boilerplate app in working directory');\n};\n\nvar failedToRemoveDirMessage = function (dirPath) {\n  errorMessage('Failed to remove existing directory at ' + dirPath + '. This directory may be used by another program or you may not have the permission to remove it.');\n};\n\nvar failedToCreateMessage = function () {\n  errorMessage('Failed to create necessary files. Please check your permissions and try again.');\n};\n\nvar promptConfirm = function (message, callback) {\n  prompt([\n    {\n      type: 'confirm',\n      message: message,\n      name: 'result'\n    }\n  ]).then((answers) => {\n    callback(answers.result);\n  }).catch((err) => {\n    errorMessage(err.message);\n    process.exit();\n  });\n};\n\nvar copyDirRecursive = function (src, dest) {\n  try {\n    fs.copySync(src, dest);\n    return true;\n  } catch (e) {\n    failedToCreateMessage();\n  }\n  return false;\n};\n\nvar rmdirRecursive = function (dirname) {\n  try {\n    fs.removeSync(dirname);\n    return true;\n  } catch (e) {\n    failedToRemoveDirMessage(dirname);\n  }\n  return false;\n};\n\nif (argv.help) {\n  showCorrectUsage();\n  process.exit();\n};\n\nif (argv.v) {\n  var scDir = __dirname + '/../';\n  var scPkg = parsePackageFile(scDir);\n  console.log('v' + scPkg.version);\n  process.exit();\n};\n\nvar wd = process.cwd();\n\nvar sampleDir = __dirname + '/../sample';\nvar destDir = path.normalize(wd + '/' + arg1);\nvar clientFileSourcePath = path.normalize(destDir + '/node_modules/socketcluster-client/socketcluster.js');\nvar clientFileDestPath = path.normalize(destDir + '/public/socketcluster.js');\n\nvar createFail = function () {\n  errorMessage(\"Failed to create SocketCluster sample app.\");\n  process.exit();\n};\n\nvar createSuccess = function () {\n  console.log('Installing app dependencies using npm. This could take a while...');\n\n  var npmCommand = (process.platform === \"win32\" ? \"npm.cmd\" : \"npm\");\n  var options = {\n    cwd: destDir,\n    maxBuffer: Infinity\n  };\n\n  var npmProcess = spawn(npmCommand, ['install'], options);\n\n  npmProcess.stdout.on('data', function (data) {\n    process.stdout.write(data);\n  });\n\n  npmProcess.stderr.on('data', function (data) {\n    process.stderr.write(data);\n  });\n\n  npmProcess.on('close', function (code) {\n    if (code) {\n      errorMessage('Failed to install npm dependencies. Exited with code ' + code + '.');\n    } else {\n      try {\n        fs.writeFileSync(clientFileDestPath, fs.readFileSync(clientFileSourcePath));\n        successMessage(\"SocketCluster sample '\" + destDir + \"' was setup successfully.\");\n      } catch (err) {\n        warningMessage(\"Failed to copy file from '\" + clientFileSourcePath + \"' to '\" +\n          clientFileDestPath + \"' - Try copying it manually.\");\n      }\n    }\n    process.exit(code);\n  });\n\n  npmProcess.stdin.end();\n};\n\nvar setupMessage = function () {\n  console.log('Creating app structure...');\n};\n\nvar confirmReplaceSetup = function (confirm) {\n  if (confirm) {\n    setupMessage();\n    if (rmdirRecursive(destDir) && copyDirRecursive(sampleDir, destDir)) {\n      createSuccess();\n    } else {\n      createFail();\n    }\n  } else {\n    errorMessage(\"SocketCluster 'create' action was aborted.\");\n    process.exit();\n  }\n};\n\nif (command == 'create') {\n  if (arg1) {\n    if (fs.existsSync(destDir)) {\n      if (force) {\n        confirmReplaceSetup(true);\n      } else {\n        var message = \"There is already a directory at \" + destDir + '. Do you want to overwrite it?';\n        promptConfirm(message, confirmReplaceSetup);\n      }\n    } else {\n      setupMessage();\n      if (copyDirRecursive(sampleDir, destDir)) {\n        createSuccess();\n      } else {\n        createFail();\n      }\n    }\n  } else {\n    errorMessage(\"The 'create' command requires a valid <appname> as argument.\");\n    showCorrectUsage();\n    process.exit();\n  }\n} else {\n  errorMessage(\"'\" + command + \"' is not a valid SocketCluster command.\");\n  showCorrectUsage();\n  process.exit();\n}\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster/lib/scworker.js":"var socketClusterServer = require('socketcluster-server');\nvar EventEmitter = require('events').EventEmitter;\nvar crypto = require('crypto');\nvar domain = require('sc-domain');\nvar http = require('http');\nvar https = require('https');\nvar fs = require('fs');\nvar base64id = require('base64id');\nvar async = require('async');\nvar AuthEngine = require('sc-auth').AuthEngine;\n\nvar scErrors = require('sc-errors');\nvar InvalidActionError = scErrors.InvalidActionError;\nvar ResourceLimitError = scErrors.ResourceLimitError;\nvar BrokerError = scErrors.BrokerError;\nvar HTTPServerError = scErrors.HTTPServerError;\n\nvar SCWorker = function (options) {\n  var self = this;\n\n  this.EVENT_ERROR = 'error';\n  this.EVENT_WARNING = 'warning';\n  this.EVENT_EXIT = 'exit';\n  this.EVENT_READY = 'ready';\n  this.EVENT_CONNECTION = 'connection';\n\n  this.MIDDLEWARE_START = 'start';\n\n  this.type = 'worker';\n\n  this._errorDomain = domain.create();\n  this._errorDomain.on('error', function () {\n    self.errorHandler.apply(self, arguments);\n  });\n\n  this.start = this._errorDomain.bind(this._start);\n  this._errorDomain.run(function () {\n    self._init(options);\n  });\n};\n\nSCWorker.prototype = Object.create(EventEmitter.prototype);\n\nSCWorker.prototype.setAuthEngine = function (authEngine) {\n  this.auth = authEngine;\n\n  this.httpServer.auth = this.auth;\n  this.scServer.setAuthEngine(this.auth);\n};\n\nSCWorker.prototype.setCodecEngine = function (codecEngine) {\n  this.codec = codecEngine;\n  this.scServer.setCodecEngine(this.codec);\n};\n\nSCWorker.prototype._init = function (options) {\n  var self = this;\n\n  this.options = {};\n\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      this.options[i] = options[i];\n    }\n  }\n\n  this.id = this.options.id;\n  this.isLeader = this.id == 0;\n\n  this._middleware = {};\n  this._middleware[this.MIDDLEWARE_START] = [];\n\n  if (this.options.downgradeToUser && process.setuid) {\n    try {\n      process.setuid(this.options.downgradeToUser);\n    } catch (err) {\n      this._errorDomain.emit('error', new InvalidActionError('Could not downgrade to user \"' + this.options.downgradeToUser +\n        '\" - Either this user does not exist or the current process does not have the permission' +\n        ' to switch to it.'));\n    }\n  }\n\n  this.brokerEngine = require(this.options.brokerEngine);\n\n  this._paths = options.paths;\n\n  this._httpRequestCount = 0;\n  this._wsRequestCount = 0;\n  this._httpRPM = 0;\n  this._wsRPM = 0;\n\n  this.brokerEngineClient = new this.brokerEngine.Client({\n    brokers: this.options.brokers,\n    secretKey: this.options.secretKey,\n    pubSubBatchDuration: this.options.pubSubBatchDuration\n  });\n\n  this.brokerEngineClient.on('error', function (err) {\n    var error;\n    if (typeof err == 'string') {\n      error = new BrokerError(err);\n    } else {\n      error = err;\n    }\n    self._errorDomain.emit('error', error);\n  });\n  this.brokerEngineClient.on('warning', function () {\n    self.warningHandler.apply(self, arguments);\n  });\n  this.exchange = this.global = this.brokerEngineClient.exchange();\n\n  if (this.options.httpServerModule) {\n    var httpServerFactory = require(this.options.httpServerModule);\n    this.httpServer = httpServerFactory.createServer(this.options.protocolOptions);\n  } else {\n    if (this.options.protocol == 'https') {\n      this.httpServer = https.createServer(this.options.protocolOptions);\n    } else {\n      this.httpServer = http.createServer();\n    }\n  }\n  this.httpServer.on('request', this._httpRequestHandler.bind(this));\n  this.httpServer.on('upgrade', this._httpRequestHandler.bind(this));\n\n  this.httpServer.exchange = this.httpServer.global = this.exchange;\n\n  var httpServerErrorDomain = domain.create();\n  httpServerErrorDomain.add(this.httpServer);\n  httpServerErrorDomain.on('error', function (err) {\n    if (typeof err == 'string') {\n      error = new HTTPServerError(err);\n    } else {\n      error = err;\n    }\n    self._errorDomain.emit('error', error);\n  });\n\n  var secure = this.options.protocol == 'https' ? 1 : 0;\n\n  this.scServer = socketClusterServer.attach(this.httpServer, {\n    brokerEngine: this.brokerEngineClient,\n    wsEngine: this._paths.wsEnginePath,\n    allowClientPublish: this.options.allowClientPublish,\n    handshakeTimeout: this.options.handshakeTimeout,\n    ackTimeout: this.options.ackTimeout,\n    pingTimeout: this.options.pingTimeout,\n    pingInterval: this.options.pingInterval,\n    origins: this.options.origins,\n    appName: this.options.appName,\n    path: this.options.path,\n    authKey: this.options.authKey,\n    authPrivateKey: this.options.authPrivateKey,\n    authPublicKey: this.options.authPublicKey,\n    authAlgorithm: this.options.authAlgorithm,\n    authSignAsync: this.options.authSignAsync,\n    authVerifyAsync: this.options.authVerifyAsync,\n    authDefaultExpiry: this.options.authDefaultExpiry,\n    middlewareEmitWarnings: this.options.middlewareEmitWarnings,\n    socketChannelLimit: this.options.socketChannelLimit,\n    perMessageDeflate: this.options.perMessageDeflate\n  });\n\n  if (this.brokerEngineClient.setSCServer) {\n    this.brokerEngineClient.setSCServer(this.scServer);\n  }\n\n  // Default authentication engine\n  this.setAuthEngine(new AuthEngine());\n  this.codec = this.scServer.codec;\n\n  this.scServer.on('_connection', function (socket) {\n    // The connection event counts as a WS request\n    self._wsRequestCount++;\n    socket.on('message', function () {\n      self._wsRequestCount++;\n    });\n    self.emit(self.EVENT_CONNECTION, socket);\n  });\n\n  this.scServer.on('warning', function () {\n    self.warningHandler.apply(self, arguments);\n  });\n\n  this._socketPath = this.scServer.getPath();\n  this._socketPathRegex = new RegExp('^' + this._socketPath);\n\n  this._errorDomain.add(this.scServer);\n\n  this.scServer.on('ready', function () {\n    self.emit(self.EVENT_READY);\n  });\n};\n\nSCWorker.prototype.open = function () {\n  this._startServer();\n};\n\nSCWorker.prototype.close = function (callback) {\n  this.scServer.close();\n  this.httpServer.close(callback);\n};\n\n// getSocketURL is deprecated\nSCWorker.prototype.getSocketPath = SCWorker.prototype.getSocketURL = function () {\n  return this._socketPath;\n};\n\nSCWorker.prototype.addMiddleware = function (type, middleware) {\n  this._middleware[type].push(middleware);\n};\n\nSCWorker.prototype.removeMiddleware = function (type, middleware) {\n  var middlewareFunctions = this._middleware[type];\n\n  this._middleware[type] = middlewareFunctions.filter(function (fn) {\n    return fn != middleware;\n  });\n};\n\nSCWorker.prototype._startServer = function () {\n  var self = this;\n\n  var options = this.options;\n\n  var start = function () {\n    if (options.tcpSynBacklog != null) {\n      self.httpServer.listen(options.sourcePort, options.host, options.tcpSynBacklog);\n    } else if (options.host != null) {\n      self.httpServer.listen(options.sourcePort, options.host);\n    } else {\n      self.httpServer.listen(options.sourcePort);\n    }\n  };\n\n  var startMiddleware = this._middleware[this.MIDDLEWARE_START];\n  if (startMiddleware.length) {\n    var callbackInvoked = false;\n\n    async.applyEachSeries(startMiddleware, options, function (err) {\n      if (callbackInvoked) {\n        self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_START + ' middleware was already invoked'));\n      } else {\n        callbackInvoked = true;\n        if (err) {\n          throw err;\n        } else {\n          start();\n        }\n      }\n    });\n  } else {\n    start();\n  }\n};\n\nSCWorker.prototype._start = function () {\n  var self = this;\n\n  this._httpRequestCount = 0;\n  this._wsRequestCount = 0;\n  this._httpRPM = 0;\n  this._wsRPM = 0;\n\n  if (this._statusInterval != null) {\n    clearInterval(this._statusInterval);\n  }\n  this._statusInterval = setInterval(this._calculateStatus.bind(this), this.options.workerStatusInterval);\n\n  // Run the initController to initialize the global context\n  if (this._paths.appInitControllerPath != null) {\n      this._initController = require(this._paths.appInitControllerPath);\n      this._initController.run(this);\n  }\n\n  this._workerController = require(this._paths.appWorkerControllerPath);\n  this._workerController.run(this);\n\n  this._startServer();\n};\n\nSCWorker.prototype._httpRequestHandler = function (req, res) {\n  var self = this;\n\n  this._httpRequestCount++;\n\n  req.exchange = req.global = this.exchange;\n\n  var forwardedFor = req.headers['x-forwarded-for'];\n\n  if (forwardedFor) {\n    var forwardedClientIP;\n    if (forwardedFor.indexOf(',') > -1) {\n      forwardedClientIP = forwardedFor.split(',')[0];\n    } else {\n      forwardedClientIP = forwardedFor;\n    }\n    req.forwardedForAddress = forwardedClientIP;\n  }\n  if (req.connection) {\n    req.remoteAddress = req.connection.remoteAddress;\n    req.remoteFamily = req.connection.remoteFamily;\n    req.remotePort = req.connection.remotePort;\n  } else if (req.socket) {\n    req.remoteAddress = req.socket.remoteAddress;\n    req.remoteFamily = req.socket.remoteFamily;\n    req.remotePort = req.socket.remotePort;\n  }\n};\n\nSCWorker.prototype.getSCServer = function () {\n  return this.scServer;\n};\n\nSCWorker.prototype.getHTTPServer = function () {\n  return this.httpServer;\n};\n\nSCWorker.prototype._calculateStatus = function () {\n  var perMinuteFactor = 60000 / this.options.workerStatusInterval;\n  this._httpRPM = this._httpRequestCount * perMinuteFactor;\n  this._wsRPM = this._wsRequestCount * perMinuteFactor;\n  this._httpRequestCount = 0;\n  this._wsRequestCount = 0;\n\n  var memThreshold = this.options.killWorkerMemoryThreshold;\n\n  if (memThreshold != null) {\n    var memoryUsage = process.memoryUsage();\n    if (memoryUsage.heapUsed > memThreshold) {\n      var message = 'Worker killed itself because its memory ';\n      message += 'usage of ' + memoryUsage.heapUsed + ' exceeded ';\n      message += 'the killWorkerMemoryThreshold of ' + memThreshold;\n      var warning = new ResourceLimitError(message);\n      this.warningHandler(warning);\n      process.exit();\n    }\n  }\n};\n\nSCWorker.prototype.getStatus = function () {\n  return {\n    clientCount: this.scServer.clientsCount,\n    httpRPM: this._httpRPM,\n    wsRPM: this._wsRPM\n  };\n};\n\nSCWorker.prototype.sendToMaster = function (data) {\n  process.send({\n    type: 'workerMessage',\n    data: data,\n    workerId: this.id\n  });\n};\n\nSCWorker.prototype.handleMasterEvent = function () {\n  this.emit.apply(this, arguments);\n};\n\nSCWorker.prototype.handleMasterMessage = function (message) {\n  this.emit('masterMessage', message.data);\n};\n\nSCWorker.prototype.errorHandler = function (err) {\n  this.emit(this.EVENT_ERROR, err);\n};\n\nSCWorker.prototype.warningHandler = function (warning) {\n  this.emit(this.EVENT_WARNING, warning);\n};\n\nmodule.exports = SCWorker;\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster-server/index.js":"/**\n * Module dependencies.\n */\n\nvar http = require('http');\n\n/**\n * Expose SCServer constructor.\n *\n * @api public\n */\n\nmodule.exports.SCServer = require('./scserver');\n\n/**\n * Expose SCSocket constructor.\n *\n * @api public\n */\n\nmodule.exports.SCSocket = require('./scsocket');\n\n/**\n * Creates an http.Server exclusively used for WS upgrades.\n *\n * @param {Number} port\n * @param {Function} callback\n * @param {Object} options\n * @return {SCServer} websocket cluster server\n * @api public\n */\n\nmodule.exports.listen = function (port, options, fn) {\n  if ('function' == typeof options) {\n    fn = options;\n    options = {};\n  }\n\n  var server = http.createServer(function (req, res) {\n    res.writeHead(501);\n    res.end('Not Implemented');\n  });\n\n  var engine = module.exports.attach(server, options);\n  engine.httpServer = server;\n  server.listen(port, fn);\n\n  return engine;\n};\n\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @return {SCServer} websocket cluster server\n * @api public\n */\n\nmodule.exports.attach = function (server, options) {\n  if (options == null) {\n    options = {};\n  }\n  options.httpServer = server;\n  var socketClusterServer = new module.exports.SCServer(options);\n  return socketClusterServer;\n};\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster-server/scserver.js":"var SCSocket = require('./scsocket');\nvar AuthEngine = require('sc-auth').AuthEngine;\nvar formatter = require('sc-formatter');\nvar EventEmitter = require('events').EventEmitter;\nvar base64id = require('base64id');\nvar async = require('async');\nvar url = require('url');\nvar domain = require('sc-domain');\nvar crypto = require('crypto');\nvar uuid = require('uuid');\nvar SCSimpleBroker = require('sc-simple-broker').SCSimpleBroker;\n\nvar scErrors = require('sc-errors');\nvar AuthTokenExpiredError = scErrors.AuthTokenExpiredError;\nvar AuthTokenInvalidError = scErrors.AuthTokenInvalidError;\nvar AuthTokenNotBeforeError = scErrors.AuthTokenNotBeforeError;\nvar AuthTokenError = scErrors.AuthTokenError;\nvar SilentMiddlewareBlockedError = scErrors.SilentMiddlewareBlockedError;\nvar InvalidOptionsError = scErrors.InvalidOptionsError;\nvar InvalidActionError = scErrors.InvalidActionError;\nvar BrokerError = scErrors.BrokerError;\nvar ServerProtocolError = scErrors.ServerProtocolError;\n\n\nvar SCServer = function (options) {\n  var self = this;\n\n  var opts = {\n    brokerEngine: new SCSimpleBroker(),\n    wsEngine: 'uws',\n    allowClientPublish: true,\n    ackTimeout: 10000,\n    handshakeTimeout: 10000,\n    pingTimeout: 20000,\n    pingInterval: 8000,\n    origins: '*:*',\n    appName: uuid.v4(),\n    path: '/socketcluster/',\n    authDefaultExpiry: 86400,\n    authSignAsync: false,\n    authVerifyAsync: true,\n    middlewareEmitWarnings: true\n  };\n\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n\n  this.MIDDLEWARE_HANDSHAKE = 'handshake';\n  this.MIDDLEWARE_EMIT = 'emit';\n  this.MIDDLEWARE_SUBSCRIBE = 'subscribe';\n  this.MIDDLEWARE_PUBLISH_IN = 'publishIn';\n  this.MIDDLEWARE_PUBLISH_OUT = 'publishOut';\n  this.MIDDLEWARE_AUTHENTICATE = 'authenticate';\n\n  // Deprecated\n  this.MIDDLEWARE_PUBLISH = this.MIDDLEWARE_PUBLISH_IN;\n\n  this._subscribeEvent = '#subscribe';\n  this._publishEvent = '#publish';\n\n  this._middleware = {};\n  this._middleware[this.MIDDLEWARE_HANDSHAKE] = [];\n  this._middleware[this.MIDDLEWARE_EMIT] = [];\n  this._middleware[this.MIDDLEWARE_SUBSCRIBE] = [];\n  this._middleware[this.MIDDLEWARE_PUBLISH_IN] = [];\n  this._middleware[this.MIDDLEWARE_PUBLISH_OUT] = [];\n  this._middleware[this.MIDDLEWARE_AUTHENTICATE] = [];\n\n  this.origins = opts.origins;\n  this._allowAllOrigins = this.origins.indexOf('*:*') != -1;\n\n  this.ackTimeout = opts.ackTimeout;\n  this.handshakeTimeout = opts.handshakeTimeout;\n  this.pingInterval = opts.pingInterval;\n  this.pingTimeout = opts.pingTimeout;\n  this.allowClientPublish = opts.allowClientPublish;\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.httpServer = opts.httpServer;\n  this.socketChannelLimit = opts.socketChannelLimit;\n\n  this.brokerEngine = opts.brokerEngine;\n  this.appName = opts.appName || '';\n  this.middlewareEmitWarnings = opts.middlewareEmitWarnings;\n  this._path = opts.path;\n  this.isReady = false;\n\n  this.brokerEngine.once('ready', function () {\n    self.isReady = true;\n    EventEmitter.prototype.emit.call(self, 'ready');\n  });\n\n  var wsEngine = require(opts.wsEngine);\n  if (!wsEngine || !wsEngine.Server) {\n    throw new InvalidOptionsError('The wsEngine option must be a path or module name which points ' +\n      'to a valid WebSocket engine module with a compatible interface');\n  }\n  var WSServer = wsEngine.Server;\n\n  if (opts.authPrivateKey != null || opts.authPublicKey != null) {\n    if (opts.authPrivateKey == null) {\n      throw new InvalidOptionsError('The authPrivateKey option must be specified if authPublicKey is specified');\n    } else if (opts.authPublicKey == null) {\n      throw new InvalidOptionsError('The authPublicKey option must be specified if authPrivateKey is specified');\n    }\n    this.signatureKey = opts.authPrivateKey;\n    this.verificationKey = opts.authPublicKey;\n  } else {\n    if (opts.authKey == null) {\n      opts.authKey = crypto.randomBytes(32).toString('hex');\n    }\n    this.signatureKey = opts.authKey;\n    this.verificationKey = opts.authKey;\n  }\n\n  this.authVerifyAsync = opts.authVerifyAsync;\n  this.authSignAsync = opts.authSignAsync;\n\n  this.defaultVerificationOptions = {\n    async: this.authVerifyAsync\n  };\n  this.defaultSignatureOptions = {\n    expiresIn: opts.authDefaultExpiry,\n    async: this.authSignAsync\n  };\n\n  if (opts.authAlgorithm != null) {\n    this.defaultVerificationOptions.algorithms = [opts.authAlgorithm];\n    this.defaultSignatureOptions.algorithm = opts.authAlgorithm;\n  }\n\n  if (opts.authEngine) {\n    this.auth = opts.authEngine;\n  } else {\n    // Default authentication engine\n    this.auth = new AuthEngine();\n  }\n\n  if (opts.codecEngine) {\n    this.codec = opts.codecEngine;\n  } else {\n    // Default codec engine\n    this.codec = formatter;\n  }\n\n  this.clients = {};\n  this.clientsCount = 0;\n\n  this.exchange = this.global = this.brokerEngine.exchange();\n\n  this.wsServer = new WSServer({\n    server: this.httpServer,\n    path: this._path,\n    clientTracking: false,\n    perMessageDeflate: this.perMessageDeflate,\n    handleProtocols: opts.handleProtocols,\n    verifyClient: this.verifyHandshake.bind(this)\n  });\n\n  this.wsServer.on('error', this._handleServerError.bind(this));\n  this.wsServer.on('connection', this._handleSocketConnection.bind(this));\n};\n\nSCServer.prototype = Object.create(EventEmitter.prototype);\n\nSCServer.prototype.setAuthEngine = function (authEngine) {\n  this.auth = authEngine;\n};\n\nSCServer.prototype.setCodecEngine = function (codecEngine) {\n  this.codec = codecEngine;\n};\n\nSCServer.prototype._handleServerError = function (error) {\n  if (typeof error == 'string') {\n    error = new ServerProtocolError(error);\n  }\n  this.emit('error', error);\n};\n\nSCServer.prototype._handleSocketError = function (error) {\n  // We don't want to crash the entire worker on socket error\n  // so we emit it as a warning instead.\n  this.emit('warning', error);\n};\n\nSCServer.prototype._handleHandshakeTimeout = function (scSocket) {\n  scSocket.disconnect(4005);\n};\n\nSCServer.prototype._subscribeSocket = function (socket, channelOptions, callback) {\n  var self = this;\n\n  if (channelOptions instanceof Array) {\n    var tasks = [];\n    for (var i in channelOptions) {\n      if (channelOptions.hasOwnProperty(i)) {\n        (function (singleChannelOptions) {\n          tasks.push(function (cb) {\n            self._subscribeSocketToSingleChannel(socket, singleChannelOptions, cb);\n          });\n        })(channelOptions[i]);\n      }\n    }\n    async.waterfall(tasks, function (err) {\n      callback && callback(err);\n    });\n  } else {\n    this._subscribeSocketToSingleChannel(socket, channelOptions, callback);\n  }\n};\n\nSCServer.prototype._subscribeSocketToSingleChannel = function (socket, channelOptions, callback) {\n  var self = this;\n  var channelName = channelOptions.channel;\n\n  if (this.socketChannelLimit && socket.channelSubscriptionsCount >= this.socketChannelLimit) {\n    callback && callback('Socket ' + socket.id + ' tried to exceed the channel subscription limit of ' +\n      this.socketChannelLimit);\n  } else {\n    if (socket.channelSubscriptionsCount == null) {\n      socket.channelSubscriptionsCount = 0;\n    }\n    if (socket.channelSubscriptions[channelName] == null) {\n      socket.channelSubscriptions[channelName] = true;\n      socket.channelSubscriptionsCount++;\n    }\n\n    this.brokerEngine.subscribeSocket(socket, channelName, function (err) {\n      if (err) {\n        delete socket.channelSubscriptions[channelName];\n        socket.channelSubscriptionsCount--;\n      } else {\n        socket.emit('subscribe', channelName, channelOptions);\n      }\n      callback && callback(err);\n    });\n  }\n};\n\nSCServer.prototype._unsubscribeSocket = function (socket, channels, callback) {\n  var self = this;\n\n  if (channels == null) {\n    channels = [];\n    for (var channel in socket.channelSubscriptions) {\n      if (socket.channelSubscriptions.hasOwnProperty(channel)) {\n        channels.push(channel);\n      }\n    }\n  }\n  if (channels instanceof Array) {\n    var tasks = [];\n    var len = channels.length;\n    for (var i = 0; i < len; i++) {\n      (function (channel) {\n        tasks.push(function (cb) {\n          self._unsubscribeSocketFromSingleChannel(socket, channel, cb);\n        });\n      })(channels[i]);\n    }\n    async.waterfall(tasks, function (err) {\n      callback && callback(err);\n    });\n  } else {\n    this._unsubscribeSocketFromSingleChannel(socket, channels, callback);\n  }\n};\n\nSCServer.prototype._unsubscribeSocketFromSingleChannel = function (socket, channel, callback) {\n  var self = this;\n\n  delete socket.channelSubscriptions[channel];\n  if (socket.channelSubscriptionsCount != null) {\n    socket.channelSubscriptionsCount--;\n  }\n\n  this.brokerEngine.unsubscribeSocket(socket, channel, function (err) {\n    socket.emit('unsubscribe', channel);\n    callback && callback(err);\n  });\n};\n\nSCServer.prototype._processTokenError = function (err) {\n  var authError = null;\n  var isBadToken = true;\n\n  if (err) {\n    if (err.name == 'TokenExpiredError') {\n      authError = new AuthTokenExpiredError(err.message, err.expiredAt);\n    } else if (err.name == 'JsonWebTokenError') {\n      authError = new AuthTokenInvalidError(err.message);\n    } else if (err.name == 'NotBeforeError') {\n      authError = new AuthTokenNotBeforeError(err.message);\n      // In this case, the token is good; it's just not active yet.\n      isBadToken = false;\n    } else {\n      authError = new AuthTokenError(err.message);\n    }\n  }\n\n  return {\n    authError: authError,\n    isBadToken: isBadToken\n  };\n};\n\nSCServer.prototype._emitBadAuthTokenError = function (scSocket, error, signedAuthToken) {\n  scSocket.emit('badAuthToken', {\n    authError: error,\n    signedAuthToken: signedAuthToken\n  });\n  this.emit('badSocketAuthToken', {\n    socket: scSocket,\n    authError: error,\n    signedAuthToken: signedAuthToken\n  });\n};\n\nSCServer.prototype._processAuthToken = function (scSocket, signedAuthToken, callback) {\n  var self = this;\n\n  this.auth.verifyToken(signedAuthToken, this.verificationKey, this.defaultVerificationOptions, function (err, authToken) {\n    if (authToken) {\n      scSocket.signedAuthToken = signedAuthToken;\n      scSocket.authToken = authToken;\n      scSocket.authState = scSocket.AUTHENTICATED;\n    } else {\n      scSocket.signedAuthToken = null;\n      scSocket.authToken = null;\n      scSocket.authState = scSocket.UNAUTHENTICATED;\n    }\n\n    // If the socket is authenticated, pass it through the MIDDLEWARE_AUTHENTICATE middleware.\n    // If the token is bad, we will tell the client to remove it.\n    // If there is an error but the token is good, then we will send back a 'quiet' error instead\n    // (as part of the status object only).\n    if (scSocket.authToken) {\n      self._passThroughAuthenticateMiddleware({\n        socket: scSocket,\n        signedAuthToken: scSocket.signedAuthToken,\n        authToken: scSocket.authToken\n      }, function (middlewareError, isBadToken) {\n        if (middlewareError) {\n          scSocket.authToken = null;\n          scSocket.authState = scSocket.UNAUTHENTICATED;\n          if (isBadToken) {\n            self._emitBadAuthTokenError(scSocket, middlewareError, signedAuthToken);\n          }\n        }\n        // If an error is passed back from the authenticate middleware, it will be treated as a\n        // server warning and not a socket error.\n        callback(middlewareError, isBadToken || false);\n      });\n    } else {\n      var errorData = self._processTokenError(err);\n\n      // If the error is related to the JWT being badly formatted, then we will\n      // treat the error as a socket error.\n      if (err && signedAuthToken != null) {\n        scSocket.emit('error', err);\n        if (errorData.isBadToken) {\n          self._emitBadAuthTokenError(scSocket, err, signedAuthToken);\n        }\n      }\n      callback(errorData.authError, errorData.isBadToken);\n    }\n  });\n};\n\nSCServer.prototype._handleSocketConnection = function (wsSocket) {\n  var self = this;\n\n  var id = this.generateId();\n\n  var socketDomain = domain.create();\n  var scSocket = new SCSocket(id, this, wsSocket);\n  socketDomain.add(scSocket);\n\n  // Emit event to signal that a socket handshake has been initiated.\n  // The _handshake event is for internal use (including third-party plugins)\n  this.emit('_handshake', scSocket);\n  this.emit('handshake', scSocket);\n\n  socketDomain.on('error', function (err) {\n    self._handleSocketError(err);\n  });\n\n  scSocket.on('#authenticate', function (signedAuthToken, respond) {\n    self._processAuthToken(scSocket, signedAuthToken, function (err, isBadToken) {\n      if (err) {\n        if (isBadToken) {\n          scSocket.deauthenticate();\n        }\n      } else {\n        scSocket.emit('authenticate', scSocket.authToken);\n      }\n      var authStatus = {\n        isAuthenticated: !!scSocket.authToken,\n        authError: scErrors.dehydrateError(err)\n      };\n      if (err && isBadToken) {\n        respond(err, authStatus);\n      } else {\n        respond(null, authStatus);\n      }\n    });\n  });\n\n  scSocket.on('#removeAuthToken', function () {\n    var oldToken = scSocket.authToken;\n    scSocket.authToken = null;\n    scSocket.authState = scSocket.UNAUTHENTICATED;\n    scSocket.emit('deauthenticate', oldToken);\n  });\n\n  scSocket.on('#subscribe', function (channelOptions, res) {\n    if (!channelOptions) {\n      channelOptions = {};\n    } else if (typeof channelOptions == 'string') {\n      channelOptions = {\n        channel: channelOptions\n      };\n    }\n    self._subscribeSocket(scSocket, channelOptions, function (err) {\n      if (err) {\n        var error = new BrokerError('Failed to subscribe socket to channel - ' + err);\n        res(error);\n        scSocket.emit('error', error);\n      } else {\n        res();\n      }\n    });\n  });\n\n  scSocket.on('#unsubscribe', function (channel, res) {\n    self._unsubscribeSocket(scSocket, channel, function (err) {\n      if (err) {\n        var error = new BrokerError('Failed to unsubscribe socket from channel - ' + err);\n        res(error);\n        scSocket.emit('error', error);\n      } else {\n        res();\n      }\n    });\n  });\n\n  scSocket.once('_disconnect', function () {\n    clearTimeout(scSocket._handshakeTimeoutRef);\n\n    scSocket.off('#handshake');\n    scSocket.off('#authenticate');\n    scSocket.off('#removeAuthToken');\n    scSocket.off('#subscribe');\n    scSocket.off('#unsubscribe');\n    scSocket.off('authenticate');\n    scSocket.off('deauthenticate');\n\n    var isClientFullyConnected = !!self.clients[id];\n\n    if (isClientFullyConnected) {\n      delete self.clients[id];\n      self.clientsCount--;\n    }\n\n    self._unsubscribeSocket(scSocket, null, function (err) {\n      if (err) {\n        scSocket.emit('error', new BrokerError('Failed to unsubscribe socket from all channels - ' + err));\n      } else if (isClientFullyConnected) {\n        self.emit('_disconnection', scSocket);\n        self.emit('disconnection', scSocket);\n      }\n    });\n  });\n\n  scSocket._handshakeTimeoutRef = setTimeout(this._handleHandshakeTimeout.bind(this, scSocket), this.handshakeTimeout);\n  scSocket.once('#handshake', function (data, respond) {\n    if (!data) {\n      data = {};\n    }\n    var signedAuthToken = data.authToken || null;\n    clearTimeout(scSocket._handshakeTimeoutRef);\n\n    self._processAuthToken(scSocket, signedAuthToken, function (err, isBadToken) {\n      var status = {\n        id: scSocket.id,\n        pingTimeout: self.pingTimeout\n      };\n\n      if (err) {\n        if (signedAuthToken != null) {\n          // Because the token is optional as part of the handshake, we don't count\n          // it as an error if the token wasn't provided.\n          status.authError = scErrors.dehydrateError(err);\n\n          if (isBadToken) {\n            scSocket.deauthenticate();\n          }\n        }\n      }\n      status.isAuthenticated = !!scSocket.authToken;\n\n      self.clients[id] = scSocket;\n      self.clientsCount++;\n\n      scSocket.state = scSocket.OPEN;\n      scSocket.exchange = scSocket.global = self.exchange;\n\n      self.emit('_connection', scSocket);\n      self.emit('connection', scSocket);\n\n      if (status.isAuthenticated) {\n        scSocket.emit('authenticate', scSocket.authToken);\n      }\n      // Treat authentication failure as a 'soft' error\n      respond(null, status);\n    });\n  });\n};\n\nSCServer.prototype.close = function () {\n  this.isReady = false;\n  this.wsServer.close.apply(this.wsServer, arguments);\n};\n\nSCServer.prototype.getPath = function () {\n  return this._path;\n};\n\nSCServer.prototype.generateId = function () {\n  return base64id.generateId();\n};\n\nSCServer.prototype.addMiddleware = function (type, middleware) {\n  this._middleware[type].push(middleware);\n};\n\nSCServer.prototype.removeMiddleware = function (type, middleware) {\n  var middlewareFunctions = this._middleware[type];\n\n  this._middleware[type] = middlewareFunctions.filter(function (fn) {\n    return fn != middleware;\n  });\n};\n\nSCServer.prototype.verifyHandshake = function (info, cb) {\n  var self = this;\n\n  var req = info.req;\n  var origin = info.origin;\n  if (origin == 'null' || origin == null) {\n    origin = '*';\n  }\n  var ok = false;\n\n  if (this._allowAllOrigins) {\n    ok = true;\n  } else {\n    try {\n      var parts = url.parse(origin);\n      parts.port = parts.port || 80;\n      ok = ~this.origins.indexOf(parts.hostname + ':' + parts.port) ||\n        ~this.origins.indexOf(parts.hostname + ':*') ||\n        ~this.origins.indexOf('*:' + parts.port);\n    } catch (e) {}\n  }\n\n  if (ok) {\n    var handshakeMiddleware = this._middleware[this.MIDDLEWARE_HANDSHAKE];\n    if (handshakeMiddleware.length) {\n      var callbackInvoked = false;\n      async.applyEachSeries(handshakeMiddleware, req, function (err) {\n        if (callbackInvoked) {\n          self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_HANDSHAKE + ' middleware was already invoked'));\n        } else {\n          callbackInvoked = true;\n          if (err) {\n            if (err === true) {\n              err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_HANDSHAKE + ' middleware', self.MIDDLEWARE_HANDSHAKE);\n            } else if (self.middlewareEmitWarnings) {\n              self.emit('warning', err);\n            }\n            cb(false, 401, err);\n          } else {\n            cb(true);\n          }\n        }\n      });\n    } else {\n      cb(true);\n    }\n  } else {\n    var err = new ServerProtocolError('Failed to authorize socket handshake - Invalid origin: ' + origin);\n    this.emit('warning', err);\n    cb(false, 403, err);\n  }\n};\n\nSCServer.prototype._isPrivateTransmittedEvent = function (event) {\n  return typeof event == 'string' && event.indexOf('#') == 0;\n};\n\nSCServer.prototype.verifyInboundEvent = function (socket, eventName, eventData, cb) {\n  var request = {\n    socket: socket,\n    event: eventName,\n    data: eventData\n  };\n\n  var token = socket.getAuthToken();\n  if (this.isAuthTokenExpired(token)) {\n    request.authTokenExpiredError = new AuthTokenExpiredError('The socket auth token has expired', token.exp);\n\n    socket.deauthenticate();\n  }\n\n  this._passThroughMiddleware(request, cb);\n};\n\nSCServer.prototype.isAuthTokenExpired = function (token) {\n  if (token && token.exp != null) {\n    var currentTime = Date.now();\n    var expiryMilliseconds = token.exp * 1000;\n    return currentTime > expiryMilliseconds;\n  }\n  return false;\n};\n\nSCServer.prototype._passThroughMiddleware = function (options, cb) {\n  var self = this;\n\n  var callbackInvoked = false;\n\n  var request = {\n    socket: options.socket\n  };\n\n  if (options.authTokenExpiredError != null) {\n    request.authTokenExpiredError = options.authTokenExpiredError;\n  }\n\n  var event = options.event;\n\n  if (this._isPrivateTransmittedEvent(event)) {\n    if (event == this._subscribeEvent) {\n      var eventData = options.data || {};\n      request.channel = eventData.channel;\n      request.waitForAuth = eventData.waitForAuth;\n      request.data = eventData.data;\n\n      if (request.waitForAuth && request.authTokenExpiredError) {\n        // If the channel has the waitForAuth flag set, then we will handle the expiry quietly\n        // and we won't pass this request through the subscribe middleware.\n        cb(request.authTokenExpiredError, eventData);\n      } else {\n        async.applyEachSeries(this._middleware[this.MIDDLEWARE_SUBSCRIBE], request,\n          function (err) {\n            if (callbackInvoked) {\n              self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_SUBSCRIBE + ' middleware was already invoked'));\n            } else {\n              callbackInvoked = true;\n              if (err) {\n                if (err === true) {\n                  err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_SUBSCRIBE + ' middleware', self.MIDDLEWARE_SUBSCRIBE);\n                } else if (self.middlewareEmitWarnings) {\n                  self.emit('warning', err);\n                }\n              }\n              if (request.data !== undefined) {\n                eventData.data = request.data;\n              }\n              cb(err, eventData);\n            }\n          }\n        );\n      }\n    } else if (event == this._publishEvent) {\n      if (this.allowClientPublish) {\n        var eventData = options.data || {};\n        request.channel = eventData.channel;\n        request.data = eventData.data;\n\n        async.applyEachSeries(this._middleware[this.MIDDLEWARE_PUBLISH_IN], request,\n          function (err) {\n            if (callbackInvoked) {\n              self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_PUBLISH_IN + ' middleware was already invoked'));\n            } else {\n              callbackInvoked = true;\n              if (request.data !== undefined) {\n                eventData.data = request.data;\n              }\n              if (err) {\n                if (err === true) {\n                  err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_PUBLISH_IN + ' middleware', self.MIDDLEWARE_PUBLISH_IN);\n                } else if (self.middlewareEmitWarnings) {\n                  self.emit('warning', err);\n                }\n                cb(err, eventData);\n              } else {\n                self.exchange.publish(request.channel, request.data, function (err) {\n                  if (err) {\n                    err = new BrokerError(err);\n                    self.emit('warning', err);\n                  }\n                  cb(err, eventData);\n                });\n              }\n            }\n          }\n        );\n      } else {\n        var noPublishError = new InvalidActionError('Client publish feature is disabled');\n        self.emit('warning', noPublishError);\n        cb(noPublishError, options.data);\n      }\n    } else {\n      // Do not allow blocking other reserved events or it could interfere with SC behaviour\n      cb(null, options.data);\n    }\n  } else {\n    request.event = event;\n    request.data = options.data;\n\n    async.applyEachSeries(this._middleware[this.MIDDLEWARE_EMIT], request,\n      function (err) {\n        if (callbackInvoked) {\n          self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_EMIT + ' middleware was already invoked'));\n        } else {\n          callbackInvoked = true;\n          if (err) {\n            if (err === true) {\n              err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_EMIT + ' middleware', self.MIDDLEWARE_EMIT);\n            } else if (self.middlewareEmitWarnings) {\n              self.emit('warning', err);\n            }\n          }\n          cb(err, request.data);\n        }\n      }\n    );\n  }\n};\n\nSCServer.prototype._passThroughAuthenticateMiddleware = function (options, cb) {\n  var self = this;\n  var callbackInvoked = false;\n\n  var request = {\n    socket: options.socket,\n    authToken: options.authToken\n  };\n\n  async.applyEachSeries(this._middleware[this.MIDDLEWARE_AUTHENTICATE], request,\n    function (err, results) {\n      if (callbackInvoked) {\n        self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_AUTHENTICATE + ' middleware was already invoked'));\n      } else {\n        var isBadToken = false;\n        if (results.length) {\n          isBadToken = results[results.length - 1] || false;\n        }\n        callbackInvoked = true;\n        if (err) {\n          if (err === true) {\n            err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_AUTHENTICATE + ' middleware', self.MIDDLEWARE_AUTHENTICATE);\n          } else if (self.middlewareEmitWarnings) {\n            self.emit('warning', err);\n          }\n        }\n        cb(err, isBadToken);\n      }\n    }\n  );\n};\n\nSCServer.prototype.verifyOutboundEvent = function (socket, eventName, eventData, options, cb) {\n  var self = this;\n\n  var callbackInvoked = false;\n\n  if (eventName == this._publishEvent) {\n    var request = {\n      socket: socket,\n      channel: eventData.channel,\n      data: eventData.data\n    };\n    async.applyEachSeries(this._middleware[this.MIDDLEWARE_PUBLISH_OUT], request,\n      function (err) {\n        if (callbackInvoked) {\n          self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_PUBLISH_OUT + ' middleware was already invoked'));\n        } else {\n          callbackInvoked = true;\n          if (request.data !== undefined) {\n            eventData.data = request.data;\n          }\n          if (err) {\n            if (err === true) {\n              err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_PUBLISH_OUT + ' middleware', self.MIDDLEWARE_PUBLISH_OUT);\n            } else if (self.middlewareEmitWarnings) {\n              self.emit('warning', err);\n            }\n            cb(err, eventData);\n          } else {\n            if (options && request.useCache) {\n              options.useCache = true;\n            }\n            cb(null, eventData);\n          }\n        }\n      }\n    );\n  } else {\n    cb(null, eventData);\n  }\n};\n\nmodule.exports = SCServer;\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster-server/scsocket.js":"var cloneDeep = require('lodash.clonedeep');\nvar SCEmitter = require('sc-emitter').SCEmitter;\nvar Response = require('./response').Response;\n\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\nvar InvalidMessageError = scErrors.InvalidMessageError;\nvar SocketProtocolError = scErrors.SocketProtocolError;\nvar TimeoutError = scErrors.TimeoutError;\n\n\nvar SCSocket = function (id, server, socket) {\n  var self = this;\n\n  SCEmitter.call(this);\n\n  this._localEvents = {\n    'open': 1,\n    'subscribe': 1,\n    'unsubscribe': 1,\n    'disconnect': 1,\n    '_disconnect': 1,\n    'message': 1,\n    'error': 1,\n    'authenticate': 1,\n    'deauthenticate': 1,\n    'badAuthToken': 1,\n    'raw': 1\n  };\n\n  this._autoAckEvents = {\n    '#publish': 1\n  };\n\n  this.id = id;\n  this.server = server;\n  this.socket = socket;\n  this.state = this.CONNECTING;\n\n  this.request = this.socket.upgradeReq || {};\n\n  // If uws module is used.\n  if (!this.request.connection) {\n    this.request.connection = this.socket._socket;\n  }\n  if (this.request.connection) {\n    this.remoteAddress = this.request.connection.remoteAddress;\n    this.remoteFamily = this.request.connection.remoteFamily;\n    this.remotePort = this.request.connection.remotePort;\n  } else {\n    this.remoteAddress = this.request.remoteAddress;\n    this.remoteFamily = this.request.remoteFamily;\n    this.remotePort = this.request.remotePort;\n  }\n  if (this.request.forwardedForAddress) {\n    this.forwardedForAddress = this.request.forwardedForAddress;\n  }\n\n  this._cid = 1;\n  this._callbackMap = {};\n\n  this.channelSubscriptions = {};\n  this.channelSubscriptionsCount = 0;\n\n  this.socket.on('error', function (err) {\n    SCEmitter.prototype.emit.call(self, 'error', err);\n  });\n\n  this.socket.on('close', function (code, data) {\n    self._onSCClose(code, data);\n  });\n\n  this._pingIntervalTicker = setInterval(this._sendPing.bind(this), this.server.pingInterval);\n  this._resetPongTimeout();\n\n  // Receive incoming raw messages\n  this.socket.on('message', function (message, flags) {\n    self._resetPongTimeout();\n\n    SCEmitter.prototype.emit.call(self, 'message', message);\n\n    var obj;\n    try {\n      obj = self.decode(message);\n    } catch (err) {\n      if (err.name == 'Error') {\n        err.name = 'InvalidMessageError';\n      }\n      SCEmitter.prototype.emit.call(self, 'error', err);\n      return;\n    }\n\n    // If pong\n    if (obj == '#2') {\n      var token = self.getAuthToken();\n      if (self.server.isAuthTokenExpired(token)) {\n        self.deauthenticate();\n      }\n    } else {\n      if (obj == null) {\n        var emptyMessageError = new InvalidMessageError('Received an empty message');\n        SCEmitter.prototype.emit.call(self, 'error', emptyMessageError);\n\n      } else if (obj.event) {\n        var eventName = obj.event;\n\n        if (self._localEvents[eventName] == null) {\n          var response = new Response(self, obj.cid);\n          self.server.verifyInboundEvent(self, eventName, obj.data, function (err, newData) {\n            if (err) {\n              response.error(err);\n            } else {\n              var eventData = newData;\n              if (eventName == '#disconnect') {\n                var disconnectData = eventData || {};\n                self._onSCClose(disconnectData.code, disconnectData.data);\n              } else {\n                if (self._autoAckEvents[eventName]) {\n                  if (eventData && eventData.data !== undefined) {\n                    response.end(eventData.data);\n                  } else {\n                    response.end();\n                  }\n                  SCEmitter.prototype.emit.call(self, eventName, eventData);\n                } else {\n                  SCEmitter.prototype.emit.call(self, eventName, eventData, response.callback.bind(response));\n                }\n              }\n            }\n          });\n        }\n      } else if (obj.rid != null) {\n        // If incoming message is a response to a previously sent message\n        var ret = self._callbackMap[obj.rid];\n        if (ret) {\n          clearTimeout(ret.timeout);\n          delete self._callbackMap[obj.rid];\n          var rehydratedError = scErrors.hydrateError(obj.error);\n          ret.callback(rehydratedError, obj.data);\n        }\n      } else {\n        // The last remaining case is to treat the message as raw\n        SCEmitter.prototype.emit.call(self, 'raw', message);\n      }\n    }\n  });\n};\n\nSCSocket.prototype = Object.create(SCEmitter.prototype);\n\nSCSocket.CONNECTING = SCSocket.prototype.CONNECTING = 'connecting';\nSCSocket.OPEN = SCSocket.prototype.OPEN = 'open';\nSCSocket.CLOSED = SCSocket.prototype.CLOSED = 'closed';\n\nSCSocket.AUTHENTICATED = SCSocket.prototype.AUTHENTICATED = 'authenticated';\nSCSocket.UNAUTHENTICATED = SCSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\n\nSCSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\nSCSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\n\nSCSocket.prototype._sendPing = function () {\n  if (this.state != this.CLOSED) {\n    this.sendObject('#1');\n  }\n};\n\nSCSocket.prototype._resetPongTimeout = function () {\n  var self = this;\n\n  clearTimeout(this._pingTimeoutTicker);\n  this._pingTimeoutTicker = setTimeout(function() {\n    self._onSCClose(4001);\n    self.socket.close(4001);\n  }, this.server.pingTimeout);\n};\n\nSCSocket.prototype._nextCallId = function () {\n  return this._cid++;\n};\n\nSCSocket.prototype.getState = function () {\n  return this.state;\n};\n\nSCSocket.prototype.getBytesReceived = function () {\n  return this.socket.bytesReceived;\n};\n\nSCSocket.prototype._onSCClose = function (code, data) {\n  clearInterval(this._pingIntervalTicker);\n  clearTimeout(this._pingTimeoutTicker);\n\n  if (this.state != this.CLOSED) {\n    this.state = this.CLOSED;\n\n    // Private disconnect event for internal use only\n    SCEmitter.prototype.emit.call(this, '_disconnect', code, data);\n    SCEmitter.prototype.emit.call(this, 'disconnect', code, data);\n\n    if (!SCSocket.ignoreStatuses[code]) {\n      var failureMessage;\n      if (data) {\n        failureMessage = 'Socket connection failed: ' + data;\n      } else {\n        failureMessage = 'Socket connection failed for unknown reasons';\n      }\n      var err = new SocketProtocolError(SCSocket.errorStatuses[code] || failureMessage, code);\n      SCEmitter.prototype.emit.call(this, 'error', err);\n    }\n  }\n};\n\nSCSocket.prototype.disconnect = function (code, data) {\n  code = code || 1000;\n\n  if (typeof code != 'number') {\n    var err = new InvalidArgumentsError('If specified, the code argument must be a number');\n    SCEmitter.prototype.emit.call(this, 'error', err);\n  }\n\n  if (this.state != this.CLOSED) {\n    var packet = {\n      code: code,\n      data: data\n    };\n    this.emit('#disconnect', packet);\n    this._onSCClose(code, data);\n    this.socket.close(code);\n  }\n};\n\nSCSocket.prototype.terminate = function () {\n  this.socket.terminate();\n};\n\nSCSocket.prototype.send = function (data, options) {\n  var self = this;\n\n  this.socket.send(data, options, function (err) {\n    if (err) {\n      self._onSCClose(1006, err.toString());\n    }\n  });\n};\n\nSCSocket.prototype.decode = function (message) {\n  return this.server.codec.decode(message);\n};\n\nSCSocket.prototype.encode = function (object) {\n  return this.server.codec.encode(object);\n};\n\nSCSocket.prototype.sendObject = function (object) {\n  var str;\n  try {\n    str = this.encode(object);\n  } catch (err) {\n    SCEmitter.prototype.emit.call(this, 'error', err);\n  }\n  if (str != null) {\n    this.send(str);\n  }\n};\n\nSCSocket.prototype.emit = function (event, data, callback, options) {\n  var self = this;\n\n  if (this._localEvents[event] == null) {\n    this.server.verifyOutboundEvent(this, event, data, options, function (err, newData) {\n      var eventObject = {\n        event: event\n      };\n      if (newData !== undefined) {\n        eventObject.data = newData;\n      }\n\n      if (err) {\n        if (callback) {\n          eventObject.cid = self._nextCallId();\n          callback(err, eventObject);\n        }\n      } else {\n        if (callback) {\n          eventObject.cid = self._nextCallId();\n          var timeout = setTimeout(function () {\n            var error = new TimeoutError(\"Event response for '\" + event + \"' timed out\");\n\n            delete self._callbackMap[eventObject.cid];\n            callback(error, eventObject);\n          }, self.server.ackTimeout);\n\n          self._callbackMap[eventObject.cid] = {callback: callback, timeout: timeout};\n        }\n        if (options && options.useCache && options.stringifiedData != null) {\n          // Optimized\n          self.send(options.stringifiedData);\n        } else {\n          self.sendObject(eventObject);\n        }\n      }\n    });\n  } else {\n    SCEmitter.prototype.emit.apply(this, arguments);\n  }\n};\n\nSCSocket.prototype.setAuthToken = function (data, options, callback) {\n  var self = this;\n\n  this.authToken = data;\n  this.authState = this.AUTHENTICATED;\n\n  if (options == null) {\n    options = {};\n  } else {\n    options = cloneDeep(options);\n    if (options.algorithm != null) {\n      delete options.algorithm;\n      var err = new InvalidArgumentsError('Cannot change auth token algorithm at runtime - It must be specified as a config option on launch');\n      SCEmitter.prototype.emit.call(this, 'error', err);\n    }\n  }\n\n  var defaultSignatureOptions = this.server.defaultSignatureOptions;\n\n  if (data && data.exp == null) {\n    options.expiresIn = defaultSignatureOptions.expiresIn;\n  }\n  if (defaultSignatureOptions.algorithm != null) {\n    options.algorithm = defaultSignatureOptions.algorithm;\n  }\n  if (defaultSignatureOptions.async != null) {\n    options.async = defaultSignatureOptions.async;\n  }\n\n  this.server.auth.signToken(data, this.server.signatureKey, options, function (err, signedToken) {\n    if (err) {\n      self._onSCClose(4002, err);\n      self.socket.close(4002);\n      callback && callback(err);\n    } else {\n      var tokenData = {\n        token: signedToken\n      };\n      self.emit('#setAuthToken', tokenData, callback);\n    }\n  });\n};\n\nSCSocket.prototype.getAuthToken = function () {\n  return this.authToken;\n};\n\nSCSocket.prototype.deauthenticate = function (callback) {\n  this.authToken = null;\n  this.authState = this.UNAUTHENTICATED;\n  this.emit('#removeAuthToken', null, callback);\n};\n\nSCSocket.prototype.kickOut = function (channel, message, callback) {\n  if (channel == null) {\n    for (var i in this.channelSubscriptions) {\n      if (this.channelSubscriptions.hasOwnProperty(i)) {\n        this.emit('#kickOut', {message: message, channel: i});\n      }\n    }\n  } else {\n    this.emit('#kickOut', {message: message, channel: channel});\n  }\n  this.server.brokerEngine.unsubscribeSocket(this, channel, callback);\n};\n\nSCSocket.prototype.subscriptions = function () {\n  var subs = [];\n  for (var i in this.channelSubscriptions) {\n    if (this.channelSubscriptions.hasOwnProperty(i)) {\n      subs.push(i);\n    }\n  }\n  return subs;\n};\n\nSCSocket.prototype.isSubscribed = function (channel) {\n  return !!this.channelSubscriptions[channel];\n};\n\nmodule.exports = SCSocket;\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster-server/response.js":"var scErrors = require('sc-errors');\nvar InvalidActionError = scErrors.InvalidActionError;\n\nvar Response = function (socket, id) {\n  this.socket = socket;\n  this.id = id;\n  this.sent = false;\n};\n\nResponse.prototype._respond = function (responseData) {\n  if (this.sent) {\n    throw new InvalidActionError('Response ' + this.id + ' has already been sent');\n  } else {\n    this.sent = true;\n    this.socket.sendObject(responseData);\n  }\n};\n\nResponse.prototype.end = function (data) {\n  if (this.id) {\n    var responseData = {\n      rid: this.id\n    };\n    if (data !== undefined) {\n      responseData.data = data;\n    }\n    this._respond(responseData);\n  }\n};\n\nResponse.prototype.error = function (error, data) {\n  if (this.id) {\n    var err = scErrors.dehydrateError(error);\n\n    var responseData = {\n      rid: this.id,\n      error: err\n    };\n    if (data !== undefined) {\n      responseData.data = data;\n    }\n\n    this._respond(responseData);\n  }\n};\n\nResponse.prototype.callback = function (error, data) {\n  if (error) {\n    this.error(error, data);\n  } else {\n    this.end(data);\n  }\n};\n\nmodule.exports.Response = Response;\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster/lib/workercluster.js":"var cluster = require('cluster');\nvar SCWorker = require('./scworker');\nvar scErrors = require('sc-errors');\nvar processTermTimeout = 10000;\n\nif (cluster.isMaster) {\n\n  process.on('disconnect', function () {\n    process.exit();\n  });\n\n  var workers;\n  var alive = true;\n  var hasExited = false;\n  var terminatedCount = 0;\n\n  var sendErrorToMaster = function (err) {\n    var error = scErrors.dehydrateError(err, true);\n    process.send({\n      type: 'error',\n      data: {\n        pid: process.pid,\n        error: error\n      }\n    });\n  };\n\n  var terminate = function () {\n    alive = false;\n    setTimeout(function () {\n      if (!hasExited) {\n        hasExited = true;\n        process.exit();\n      }\n    }, processTermTimeout);\n  };\n\n  process.on('message', function (m) {\n    if (m.type == 'init') {\n      if (m.data.schedulingPolicy != null) {\n        cluster.schedulingPolicy = m.data.schedulingPolicy;\n      }\n      if (m.data.processTermTimeout) {\n        processTermTimeout = m.data.processTermTimeout;\n      }\n\n      var workerCount = m.data.workerCount;\n      var readyCount = 0;\n      var isReady = false;\n      workers = [];\n\n      var launchWorker = function (i, respawn) {\n        var worker = cluster.fork();\n        workers[i] = worker;\n        worker.on('error', sendErrorToMaster);\n\n        worker.on('message', function (m) {\n          if (m.type == 'ready') {\n            process.send({\n              type: 'workerStart',\n              data: {\n                id: i,\n                pid: worker.process.pid,\n                respawn: respawn || false\n              }\n            });\n\n            if (!isReady && ++readyCount >= workerCount) {\n              isReady = true;\n              process.send(m);\n            }\n          } else {\n            process.send(m);\n          }\n        });\n\n        worker.on('exit', function (code, signal) {\n          if (alive) {\n            process.send({\n              type: 'workerExit',\n              data: {\n                id: i,\n                pid: worker.process.pid,\n                code: code,\n                signal: signal\n              }\n            });\n\n            if (m.data.rebootWorkerOnCrash) {\n              launchWorker(i, true);\n            }\n          } else if (++terminatedCount >= workers.length) {\n            if (!hasExited) {\n              hasExited = true;\n              process.exit();\n            }\n          }\n        });\n\n        var workerInitOptions = {};\n        for (var j in m) {\n          if (m.hasOwnProperty(j)) {\n            workerInitOptions[j] = m[j];\n          }\n        }\n        workerInitOptions.data.id = i;\n\n        worker.send(workerInitOptions);\n      };\n\n      for (var i = 0; i < workerCount; i++) {\n        launchWorker(i);\n      }\n    } else if (m.type == 'masterMessage') {\n      var targetWorker = workers[m.workerId];\n      if (targetWorker) {\n        targetWorker.send(m);\n      } else {\n        var notFoundError = new Error('Worker with id ' + m.workerId + ' does not exist');\n        sendErrorToMaster(notFoundError);\n      }\n    } else {\n      if (m.type == 'terminate' && m.data.killClusterMaster) {\n        terminate();\n      }\n      for (var i in workers) {\n        if (workers.hasOwnProperty(i)) {\n          workers[i].send(m);\n        }\n      }\n    }\n  });\n\n} else {\n\n  var handleError = function (isFatal, err) {\n    var error = scErrors.dehydrateError(err, true);\n    process.send({\n      type: 'error',\n      data: {\n        error: error,\n        workerPid: process.pid\n      }\n    }, null, function () {\n      if (isFatal) {\n        process.exit(1);\n      }\n    });\n  };\n\n  var handleWarning = function (warning) {\n    var warning = scErrors.dehydrateError(warning, true);\n    process.send({\n      type: 'warning',\n      data: {\n        error: warning,\n        workerPid: process.pid\n      }\n    });\n  };\n\n  var handleReady = function () {\n    process.send({type: 'ready'});\n  };\n\n  var handleExit = function () {\n    process.exit();\n  };\n\n  var worker;\n\n  process.on('message', function (m) {\n    if (m.type == 'init') {\n      if (m.data.processTermTimeout) {\n        processTermTimeout = m.data.processTermTimeout;\n      }\n\n      if (m.data && m.data.protocolOptions && m.data.protocolOptions.pfx) {\n        m.data.protocolOptions.pfx = new Buffer(m.data.protocolOptions.pfx, 'base64');\n      }\n\n      if (typeof m.data.authKey === 'object' && m.data.authKey !== null && m.data.authKey.type === 'Buffer') {\n        m.data.authKey = new Buffer(m.data.authKey.data, 'base64');\n      }\n\n      global.worker = worker = new SCWorker(m.data);\n\n      if (m.data.propagateErrors) {\n        worker.on('error', handleError.bind(null, worker.options.crashWorkerOnError));\n        if (m.data.propagateWarnings) {\n          worker.on('warning', handleWarning);\n        }\n        worker.on('exit', handleExit);\n      }\n\n      worker.on('ready', function () {\n        worker.start();\n        handleReady();\n      });\n    } else if (m.type == 'emit') {\n      if (m.data) {\n        worker.handleMasterEvent(m.event, m.data);\n      } else {\n        worker.handleMasterEvent(m.event);\n      }\n    } else if (m.type == 'masterMessage') {\n      worker.handleMasterMessage(m);\n    } else if (m.type == 'terminate') {\n      if (worker && !m.data.immediate) {\n        worker.close(function () {\n          process.exit();\n        });\n        setTimeout(function () {\n          process.exit();\n        }, processTermTimeout);\n      } else {\n        process.exit();\n      }\n    }\n  });\n\n  process.on('uncaughtException', function (err) {\n    handleError(true, err);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster/sample/broker.js":"var scClusterBrokerClient = require('scc-broker-client');\n\nmodule.exports.run = function (broker) {\n  console.log('   >> Broker PID:', process.pid);\n\n  // This is defined in server.js (taken from environment variable SC_CLUSTER_STATE_SERVER_HOST).\n  // If this property is defined, the broker will try to attach itself to the SC cluster for\n  // automatic horizontal scalability.\n  // This is mostly intended for the Kubernetes deployment of SocketCluster - In this case,\n  // The clustering/sharding all happens automatically.\n\n  if (broker.options.clusterStateServerHost) {\n    scClusterBrokerClient.attach(broker, {\n      stateServerHost: broker.options.clusterStateServerHost,\n      stateServerPort: broker.options.clusterStateServerPort,\n      authKey: broker.options.clusterAuthKey,\n      stateServerConnectTimeout: broker.options.clusterStateServerConnectTimeout,\n      stateServerAckTimeout: broker.options.clusterStateServerAckTimeout,\n      stateServerReconnectRandomness: broker.options.clusterStateServerReconnectRandomness\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster/sample/server.js":"var fs = require('fs');\nvar argv = require('minimist')(process.argv.slice(2));\nvar SocketCluster = require('socketcluster').SocketCluster;\nvar scHotReboot = require('sc-hot-reboot');\n\nvar workerControllerPath = argv.wc || process.env.SOCKETCLUSTER_WORKER_CONTROLLER;\nvar brokerControllerPath = argv.bc || process.env.SOCKETCLUSTER_BROKER_CONTROLLER;\nvar initControllerPath = argv.ic || process.env.SOCKETCLUSTER_INIT_CONTROLLER;\nvar environment = process.env.ENV || 'dev';\n\nvar options = {\n  workers: Number(argv.w) || Number(process.env.SOCKETCLUSTER_WORKERS) || 1,\n  brokers: Number(argv.b) || Number(process.env.SOCKETCLUSTER_BROKERS) || 1,\n  port: Number(argv.p) || Number(process.env.SOCKETCLUSTER_PORT) || 8000,\n  // If your system doesn't support 'uws', you can switch to 'ws' (which is slower but works on older systems).\n  wsEngine: process.env.SOCKETCLUSTER_WS_ENGINE || 'uws',\n  appName: argv.n || process.env.SOCKETCLUSTER_APP_NAME || null,\n  workerController: workerControllerPath || __dirname + '/worker.js',\n  brokerController: brokerControllerPath || __dirname + '/broker.js',\n  initController: initControllerPath || null,\n  socketChannelLimit: Number(process.env.SOCKETCLUSTER_SOCKET_CHANNEL_LIMIT) || 1000,\n  clusterStateServerHost: argv.cssh || process.env.SCC_STATE_SERVER_HOST || null,\n  clusterStateServerPort: process.env.SCC_STATE_SERVER_PORT || null,\n  clusterAuthKey: process.env.SCC_AUTH_KEY || null,\n  clusterStateServerConnectTimeout: Number(process.env.SCC_STATE_SERVER_CONNECT_TIMEOUT) || null,\n  clusterStateServerAckTimeout: Number(process.env.SCC_STATE_SERVER_ACK_TIMEOUT) || null,\n  clusterStateServerReconnectRandomness: Number(process.env.SCC_STATE_SERVER_RECONNECT_RANDOMNESS) || null,\n  crashWorkerOnError: argv['auto-reboot'] != false,\n  // If using nodemon, set this to true, and make sure that environment is 'dev'.\n  killMasterOnSignal: false,\n  environment: environment\n};\n\nvar SOCKETCLUSTER_OPTIONS;\n\nif (process.env.SOCKETCLUSTER_OPTIONS) {\n  SOCKETCLUSTER_OPTIONS = JSON.parse(process.env.SOCKETCLUSTER_OPTIONS);\n}\n\nfor (var i in SOCKETCLUSTER_OPTIONS) {\n  if (SOCKETCLUSTER_OPTIONS.hasOwnProperty(i)) {\n    options[i] = SOCKETCLUSTER_OPTIONS[i];\n  }\n}\n\nvar masterControllerPath = argv.mc || process.env.SOCKETCLUSTER_MASTER_CONTROLLER;\n\nvar start = function () {\n  var socketCluster = new SocketCluster(options);\n\n  if (masterControllerPath) {\n    var masterController = require(masterControllerPath);\n    masterController.run(socketCluster);\n  }\n\n  if (environment == 'dev') {\n    // This will cause SC workers to reboot when code changes anywhere in the app directory.\n    // The second options argument here is passed directly to chokidar.\n    // See https://github.com/paulmillr/chokidar#api for details.\n    console.log(`   !! The sc-hot-reboot plugin is watching for code changes in the ${__dirname} directory`);\n    scHotReboot.attach(socketCluster, {\n      cwd: __dirname,\n      ignored: ['public', 'node_modules', 'README.md', 'Dockerfile', 'server.js', 'broker.js', /[\\/\\\\]\\./, '*.log']\n    });\n  }\n};\n\nvar bootCheckInterval = Number(process.env.SOCKETCLUSTER_BOOT_CHECK_INTERVAL) || 200;\n\nif (workerControllerPath) {\n  // Detect when Docker volumes are ready.\n  var startWhenFileIsReady = (filePath) => {\n    return new Promise((resolve) => {\n      if (!filePath) {\n        resolve();\n        return;\n      }\n      var checkIsReady = () => {\n        fs.exists(filePath, (exists) => {\n          if (exists) {\n            resolve();\n          } else {\n            setTimeout(checkIsReady, bootCheckInterval);\n          }\n        });\n      };\n      checkIsReady();\n    });\n  };\n  var filesReadyPromises = [\n    startWhenFileIsReady(masterControllerPath),\n    startWhenFileIsReady(workerControllerPath),\n    startWhenFileIsReady(brokerControllerPath),\n    startWhenFileIsReady(initControllerPath)\n  ];\n  Promise.all(filesReadyPromises).then(() => {\n    start();\n  });\n} else {\n  start();\n}\n","/home/travis/build/npmtest/node-npmtest-socketcluster/node_modules/socketcluster/sample/worker.js":"var fs = require('fs');\nvar express = require('express');\nvar serveStatic = require('serve-static');\nvar path = require('path');\nvar morgan = require('morgan');\nvar healthChecker = require('sc-framework-health-check');\n\nmodule.exports.run = function (worker) {\n  console.log('   >> Worker PID:', process.pid);\n  var environment = worker.options.environment;\n\n  var app = express();\n\n  var httpServer = worker.httpServer;\n  var scServer = worker.scServer;\n\n  if (environment == 'dev') {\n    // Log every HTTP request. See https://github.com/expressjs/morgan for other\n    // available formats.\n    app.use(morgan('dev'));\n  }\n  app.use(serveStatic(path.resolve(__dirname, 'public')));\n\n  // Add GET /health-check express route\n  healthChecker.attach(worker, app);\n\n  httpServer.on('request', app);\n\n  var count = 0;\n\n  /*\n    In here we handle our incoming realtime connections and listen for events.\n  */\n  scServer.on('connection', function (socket) {\n\n    // Some sample logic to show how to handle client events,\n    // replace this with your own logic\n\n    socket.on('sampleClientEvent', function (data) {\n      count++;\n      console.log('Handled sampleClientEvent', data);\n      scServer.exchange.publish('sample', count);\n    });\n\n    var interval = setInterval(function () {\n      socket.emit('rand', {\n        rand: Math.floor(Math.random() * 5)\n      });\n    }, 1000);\n\n    socket.on('disconnect', function () {\n      clearInterval(interval);\n    });\n  });\n};\n"}